#include "ps2recomp/elf_analyzer.h"
#include "ps2recomp/elf_parser.h"
#include "ps2recomp/r5900_decoder.h"
#include "ps2recomp/types.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <filesystem>
#include <regex>
#include <stack>
#include <queue>
#include <fstream>
#include <iomanip>
#include <functional>
#include <limits>

namespace fs = std::filesystem;

namespace ps2recomp
{
    static bool hasPs2ApiPrefix(const std::string &name);
    static bool isDoNotSkipOrStub(const std::string &name);
    static uint32_t decodeAbsoluteJumpTarget(uint32_t instructionAddress, uint32_t targetField);
    static bool tryReadWord(const ElfParser *parser, uint32_t address, uint32_t &outWord);

    ElfAnalyzer::ElfAnalyzer(const std::string &elfPath)
        : m_elfPath(elfPath)
    {
        m_elfParser = std::make_unique<ElfParser>(elfPath);
        m_decoder = std::make_unique<R5900Decoder>();

        initializeLibraryFunctions();
    }

    ElfAnalyzer::~ElfAnalyzer() = default;

    bool ElfAnalyzer::analyze()
    {
        std::cout << "Analyzing ELF file: " << m_elfPath << std::endl;

        if (!m_elfParser->parse())
        {
            std::cerr << "Failed to parse ELF file" << std::endl;
            return false;
        }

        m_functions = m_elfParser->extractFunctions();
        m_symbols = m_elfParser->extractSymbols();
        m_sections = m_elfParser->getSections();
        m_relocations = m_elfParser->getRelocations();

        std::cout << "Extracted " << m_functions.size() << " functions" << std::endl;
        std::cout << "Extracted " << m_symbols.size() << " symbols" << std::endl;
        std::cout << "Extracted " << m_sections.size() << " sections" << std::endl;
        std::cout << "Extracted " << m_relocations.size() << " relocations" << std::endl;

        analyzeEntryPoint();
        analyzeLibraryFunctions();
        analyzeDataUsage();
        identifyPotentialPatches();
        analyzeControlFlow();
        detectJumpTables();
        analyzePerformanceCriticalPaths();
        identifyRecursiveFunctions();
        analyzeRegisterUsage();
        analyzeFunctionSignatures();
        optimizePatches();

        for (auto &func : m_functions)
        {
            if (!m_skipFunctions.contains(func.name) &&
                !m_libFunctions.contains(func.name))
            {
                categorizeFunction(func);
                func.instructions = decodeFunction(func);
            }
        }

        std::cout << "Analysis completed" << std::endl;
        std::cout << "- " << m_libFunctions.size() << " library functions to stub" << std::endl;
        std::cout << "- " << m_skipFunctions.size() << " functions to skip" << std::endl;
        std::cout << "- " << m_patches.size() << " potential patches identified" << std::endl;
        std::cout << "- " << m_jumpTables.size() << " jump tables detected" << std::endl;

        return true;
    }

    bool ElfAnalyzer::generateToml(const std::string &outputPath)
    {
        std::ofstream file(outputPath);
        if (!file)
        {
            std::cerr << "Failed to open output file: " << outputPath << std::endl;
            return false;
        }

        fs::path elfPathObj(m_elfPath);
        std::string elfFileName = elfPathObj.filename().string();

        fs::path outputPathObj(outputPath);
        fs::path outputDir = outputPathObj.parent_path();
        if (outputDir.empty())
        {
            outputDir = ".";
        }

        const fs::path generatedOutputDir = outputDir / "output";
        std::string outputDirStr = generatedOutputDir.generic_string() + "/";

        if (!fs::exists(generatedOutputDir))
        {
            fs::create_directories(generatedOutputDir);
        }

        file << "# PS2Recomp configuration for: " << elfFileName << "\n";
        file << "# Generated by ElfAnalyzer\n\n";

        file << "[general]\n";
        file << "# Path to input ELF file\n";
        file << "input = \"" << escapeBackslashes(m_elfPath) << "\"\n\n";

        file << "# Path to Ghidra exported function map (optional CSV)\n";
        file << "ghidra_output = \"\"\n\n";

        file << "# Path to output directory\n";
        file << "output = \"" << escapeBackslashes(outputDirStr) << "\"\n\n";

        file << "# Single file output mode (false for one file per function)\n";
        file << "single_file_output = true\n\n";

        file << "# Functions to stub (these will generate empty implementations)\n";
        file << "stubs = [\n";
        for (const auto &func : m_libFunctions)
        {
            file << "  \"" << func << "\",\n";
        }
        file << "]\n\n";

        file << "# Functions to skip (these will not be recompiled)\n";
        file << "skip = [\n";
        for (const auto &func : m_skipFunctions)
        {
            file << "  \"" << func << "\",\n";
        }
        file << "]\n\n";

        if (!m_jumpTables.empty())
        {
            file << "# Jump tables detected in the program\n";
            file << "[jump_tables]\n";

            for (const auto &jt : m_jumpTables)
            {
                file << "[[jump_tables.table]]\n";
                file << "address = \"0x" << std::hex << jt.address << "\"\n"
                     << std::dec;
                file << "entries = [\n";

                for (const auto &[index, target] : jt.entries)
                {
                    file << "  { index = " << index << ", target = \"0x"
                         << std::hex << target << "\" },\n"
                         << std::dec;
                }

                file << "]\n\n";
            }
        }

        if (!m_patches.empty())
        {
            file << "# Patches to apply during recompilation\n";
            file << "[patches]\n";
            file << "# Individual instruction patches\n";
            file << "instructions = [\n";
            for (const auto &[address, value] : m_patches)
            {
                file << "  { address = \"0x" << std::hex << address << "\", value = \"0x"
                     << std::hex << value << "\" },  # " << m_patchReasons[address] << "\n";
            }
            file << "]\n\n";
        }

        file << "# Performance critical functions (may need manual optimization)\n";
        file << "[performance]\n";
        file << "critical = [\n";
        for (const auto &func : m_functions)
        {
            if (hasMMIInstructions(func) || hasVUInstructions(func))
            {
                file << "  \"" << func.name << "\", # Uses SIMD instructions\n";
            }
            else if (isLoopHeavyFunction(func))
            {
                file << "  \"" << func.name << "\", # Contains heavy loops\n";
            }
        }
        file << "]\n\n";

        std::cout << "Generated TOML configuration: " << outputPath << std::endl;
        return true;
    }

    void ElfAnalyzer::initializeLibraryFunctions()
    {
        // Standard C library functions
        const std::vector<std::string> stdLibFuncs = {
            // I/O functions
            "printf", "sprintf", "snprintf", "fprintf", "vprintf", "vfprintf", "vsprintf", "vsnprintf",
            "puts", "putchar", "getchar", "gets", "fgets", "fputs", "scanf", "fscanf", "sscanf",
            "sprint", "sbprintf",

            // Memory management
            "malloc", "free", "calloc", "realloc", "aligned_alloc", "posix_memalign",

            // Memory manipulation
            "memcpy", "memset", "memmove", "memcmp", "memcpy2", "memchr", "bcopy", "bzero",

            // String manipulation
            "strcpy", "strncpy", "strcat", "strncat", "strcmp", "strncmp", "strlen", "strstr",
            "strchr", "strrchr", "strdup", "strtok", "strtok_r", "strerror",

            // File operations
            "fopen", "fclose", "fread", "fwrite", "fseek", "ftell", "rewind", "fflush",
            "fgetc", "fgets", "feof", "ferror", "clearerr", "fileno", "tmpfile", "remove", "rename",
            "open", "close", "read", "write", "lseek", "stat", "fstat",

            // Type conversion
            "atoi", "atol", "atoll", "atof", "strtol", "strtoul", "strtoll", "strtoull", "strtod", "strtof",

            // Math functions
            "rand", "srand", "random", "srandom", "drand48", "sqrt", "pow", "exp", "log", "log10",
            "sin", "cos", "tan", "asin", "acos", "atan", "atan2", "sinh", "cosh", "tanh",
            "floor", "ceil", "fabs", "fmod", "frexp", "ldexp", "modf",

            // Time functions
            "time", "ctime", "clock", "difftime", "mktime", "localtime", "gmtime", "asctime", "strftime",
            "gettimeofday", "nanosleep", "usleep",

            // Process control
            "abort", "exit", "_exit", "atexit", "system", "getpid", "fork", "waitpid",

            // Misc
            "qsort", "bsearch", "abs", "div", "labs", "ldiv", "llabs", "lldiv",
            "isalnum", "isalpha", "isdigit", "islower", "isupper", "isspace", "tolower", "toupper",
            "setjmp", "longjmp", "getenv", "setenv", "unsetenv",
            "perror", "fputc", "getc", "ungetc", "freopen", "setvbuf", "setbuf",

            // Extra string helpers
            "strnlen", "strspn", "strcspn", "strcasecmp", "strncasecmp"};

        m_knownLibNames.insert(stdLibFuncs.begin(), stdLibFuncs.end());
    }

    void ElfAnalyzer::analyzeEntryPoint()
    {
        const uint32_t entryAddress = m_elfParser->getEntryPoint();
        auto it = std::find_if(m_functions.begin(), m_functions.end(),
                               [entryAddress](const Function &f)
                               { return f.start == entryAddress; });

        if (it == m_functions.end())
        {
            it = std::find_if(m_functions.begin(), m_functions.end(),
                              [entryAddress](const Function &f)
                              { return f.start <= entryAddress && entryAddress < f.end; });
        }

        if (it != m_functions.end())
        {
            std::cout << "Found entry point from ELF header: 0x" << std::hex << entryAddress
                      << " in function " << it->name << " (starts at 0x" << it->start << ")"
                      << std::dec << std::endl;

            m_skipFunctions.insert(it->name);

            std::vector<Instruction> instructions = decodeFunction(*it);

            for (const auto &inst : instructions)
            {
                if (inst.opcode == OPCODE_JAL)
                {
                    uint32_t target = decodeAbsoluteJumpTarget(inst.address, inst.target);

                    for (const auto &func : m_functions)
                    {
                        if (func.start == target)
                        {
                            std::cout << "Found initialization call to: " << func.name << " at 0x"
                                      << std::hex << inst.address << std::dec << std::endl;

                            if (!isDoNotSkipOrStub(func.name) && (func.name.find("init") != std::string::npos || func.name.find("Init") != std::string::npos))
                            {
                                m_skipFunctions.insert(func.name);
                            }
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            std::cout << "Entry point 0x" << std::hex << entryAddress
                      << " not mapped to an extracted function" << std::dec << std::endl;

            for (const auto &func : m_functions)
            {
                if (func.start == 0x100000 || func.start == 0x80100000)
                {
                    std::cout << "Found potential entry point by address: " << func.name
                              << " at 0x" << std::hex << func.start << std::dec << std::endl;
                    m_skipFunctions.insert(func.name);
                    break;
                }
            }
        }
    }

    void ElfAnalyzer::analyzeLibraryFunctions()
    {
        for (const auto &symbol : m_symbols)
        {
            if (symbol.isFunction)
            {
                if (isLibraryFunction(symbol.name))
                {
                    m_libFunctions.insert(symbol.name);
                }
                else if (isSystemFunction(symbol.name))
                {
                    m_skipFunctions.insert(symbol.name);
                }
            }
        }

        for (const auto &func : m_functions)
        {
            if (isLibraryFunction(func.name))
            {
                m_libFunctions.insert(func.name);
            }
            else if (isSystemFunction(func.name))
            {
                m_skipFunctions.insert(func.name);
            }
        }
    }

    void ElfAnalyzer::analyzeDataUsage()
    {
        std::cout << "Analyzing data usage patterns..." << std::endl;

        std::map<uint32_t, std::set<std::string>> memoryAccessMap;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (const auto &inst : instructions)
            {
                if (inst.opcode == OPCODE_LW || inst.opcode == OPCODE_SW ||
                    inst.opcode == OPCODE_LB || inst.opcode == OPCODE_SB ||
                    inst.opcode == OPCODE_LH || inst.opcode == OPCODE_SH ||
                    inst.opcode == OPCODE_LBU || inst.opcode == OPCODE_LHU ||
                    inst.opcode == OPCODE_LQ || inst.opcode == OPCODE_SQ)
                {
                    // Check if the memory address involves $gp (global pointer)
                    if (inst.rs == 28) // $gp is typically register 28
                    {
                        int16_t offset = static_cast<int16_t>(inst.immediate);
                        uint32_t gpValue = 0;

                        // Try to find GP value in ELF sections
                        for (const auto &section : m_sections)
                        {
                            if (section.name == ".got" || section.name == ".data" ||
                                section.name == ".sdata" || section.name == ".sbss")
                            {
                                gpValue = section.address;
                                break;
                            }
                        }

                        if (gpValue != 0)
                        {
                            uint32_t targetAddr = gpValue + offset;
                            memoryAccessMap[targetAddr].insert(func.name);

                            auto symIt = std::find_if(m_symbols.begin(), m_symbols.end(),
                                                      [targetAddr](const Symbol &s)
                                                      { return !s.isFunction && s.address == targetAddr; });

                            if (symIt != m_symbols.end())
                            {
                                std::cout << "Function " << func.name << " accesses data symbol "
                                          << symIt->name << " at 0x" << std::hex << targetAddr
                                          << std::dec << std::endl;

                                m_functionDataUsage[func.name].insert(symIt->name);
                            }
                            else
                            {
                                // Try to find the symbol it belongs to, even if not exact match
                                for (const auto &sym : m_symbols)
                                {
                                    if (!sym.isFunction && targetAddr >= sym.address &&
                                        targetAddr < sym.address + sym.size)
                                    {
                                        std::cout << "Function " << func.name << " accesses data within symbol "
                                                  << sym.name << " at offset 0x" << std::hex << (targetAddr - sym.address)
                                                  << std::dec << std::endl;

                                        m_functionDataUsage[func.name].insert(sym.name);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    // Also check for direct addressing with LUI+ADDIU combinations
                    else if (inst.opcode == OPCODE_LW || inst.opcode == OPCODE_SW)
                    {
                        // Look for the LUI instruction that sets up the high bits
                        uint32_t baseAddr = 0;
                        for (int i = 1; i <= 5 && static_cast<int>(inst.address) - i * 4 >= static_cast<int>(func.start); i++)
                        {
                            uint32_t prevAddr = inst.address - i * 4;
                            uint32_t prevInst = 0;
                            if (!tryReadWord(m_elfParser.get(), prevAddr, prevInst))
                            {
                                continue;
                            }

                            // Check if it's a LUI instruction for the same register
                            if (OPCODE(prevInst) == OPCODE_LUI && RT(prevInst) == inst.rs)
                            {
                                baseAddr = IMMEDIATE(prevInst) << 16;
                                break;
                            }
                        }

                        if (baseAddr != 0)
                        {
                            uint32_t targetAddr = baseAddr + static_cast<int16_t>(inst.immediate);

                            for (const auto &section : m_sections)
                            {
                                if (targetAddr >= section.address && targetAddr < section.address + section.size)
                                {
                                    auto symIt = std::find_if(m_symbols.begin(), m_symbols.end(),
                                                              [targetAddr](const Symbol &s)
                                                              { return !s.isFunction && s.address <= targetAddr &&
                                                                       s.address + s.size > targetAddr; });

                                    if (symIt != m_symbols.end())
                                    {
                                        std::cout << "Function " << func.name << " directly accesses "
                                                  << (inst.opcode == OPCODE_LW ? "reads from" : "writes to")
                                                  << " data symbol " << symIt->name
                                                  << " at 0x" << std::hex << targetAddr << std::dec << std::endl;

                                        m_functionDataUsage[func.name].insert(symIt->name);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Identify commonly accessed data (potential global structures)
        for (const auto &[addr, funcs] : memoryAccessMap)
        {
            if (funcs.size() > 3) // If multiple functions access this data
            {
                std::string dataName = formatAddress(addr);

                auto symIt = std::find_if(m_symbols.begin(), m_symbols.end(),
                                          [addr](const Symbol &s)
                                          { return !s.isFunction && s.address == addr; });

                if (symIt != m_symbols.end())
                {
                    dataName = symIt->name;
                }

                std::cout << "Common data: " << dataName << " at 0x" << std::hex << addr
                          << std::dec << " accessed by " << funcs.size() << " functions" << std::endl;

                m_commonDataAccess[addr] = dataName;
            }
        }

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (size_t i = 0; i < instructions.size(); i++)
            {
                const auto &inst = instructions[i];

                if ((inst.opcode == OPCODE_SPECIAL && (inst.function == SPECIAL_SLL || inst.function == SPECIAL_SLLV)) ||
                    (inst.opcode == OPCODE_SPECIAL && inst.function == SPECIAL_MULT))
                {
                    for (size_t j = i + 1; j < std::min(i + 5, instructions.size()); j++)
                    {
                        const auto &nextInst = instructions[j];

                        if ((nextInst.opcode == OPCODE_LW || nextInst.opcode == OPCODE_SW) &&
                            nextInst.rs == inst.rd)
                        {
                            std::cout << "Found possible array access in function " << func.name
                                      << " at 0x" << std::hex << nextInst.address << std::dec << std::endl;
                            break;
                        }
                    }
                }
            }
        }
    }

    void ElfAnalyzer::identifyPotentialPatches()
    {
        std::cout << "Identifying potential patches..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (size_t i = 0; i < instructions.size(); i++)
            {
                const auto &inst = instructions[i];

                if (inst.opcode == OPCODE_SPECIAL && inst.function == SPECIAL_SYSCALL)
                {
                    std::cout << "Found syscall at " << formatAddress(inst.address) << " in function " << func.name << std::endl;
                    m_patches[inst.address] = 0x00000000; // NOP
                    m_patchReasons[inst.address] = "Syscall requires special handling";
                }

                if (inst.opcode == OPCODE_COP0)
                {
                    std::cout << "Found COP0 instruction at " << formatAddress(inst.address) << " in function " << func.name << std::endl;
                    m_patches[inst.address] = 0x00000000; // NOP
                    m_patchReasons[inst.address] = "Privileged COP0 instruction";
                }

                if (inst.opcode == OPCODE_CACHE)
                {
                    std::cout << "Found CACHE instruction at " << formatAddress(inst.address) << " in function " << func.name << std::endl;
                    m_patches[inst.address] = 0x00000000; // NOP
                    m_patchReasons[inst.address] = "Cache manipulation not supported";
                }

                // Detect potential self-modifying code
                if (inst.opcode == OPCODE_SW && i + 1 < instructions.size())
                {
                    const auto &nextInst = instructions[i + 1];

                    if (nextInst.opcode == OPCODE_J || nextInst.opcode == OPCODE_JAL)
                    {
                        uint32_t jumpTarget = decodeAbsoluteJumpTarget(nextInst.address, nextInst.target);

                        for (const auto &section : m_sections)
                        {
                            if (section.isCode && jumpTarget >= section.address && jumpTarget < section.address + section.size)
                            {
                                std::cout << "Potential self-modifying code at " << formatAddress(inst.address) << " in function " << func.name << std::endl;
                                m_patches[inst.address] = 0x00000000; // NOP the store
                                m_patchReasons[inst.address] = "Potential self-modifying code";
                            }
                        }
                    }
                }

                // Detect stores to regions mapped to hardware registers
                if ((inst.opcode == OPCODE_SW || inst.opcode == OPCODE_SH || inst.opcode == OPCODE_SB) &&
                    inst.rs != 28) // Not GP-relative
                {
                    uint32_t baseAddr = 0;
                    for (int j = 1; j <= 5 && static_cast<int>(inst.address) - j * 4 >= static_cast<int>(func.start); j++)
                    {
                        uint32_t prevAddr = inst.address - j * 4;
                        uint32_t prevInst = 0;
                        if (!tryReadWord(m_elfParser.get(), prevAddr, prevInst))
                        {
                            continue;
                        }

                        if (OPCODE(prevInst) == OPCODE_LUI && RT(prevInst) == inst.rs)
                        {
                            baseAddr = IMMEDIATE(prevInst) << 16;
                            break;
                        }
                    }

                    if (baseAddr != 0)
                    {
                        uint32_t targetAddr = baseAddr + static_cast<int16_t>(inst.immediate);

                        if ((targetAddr >= 0x10000000 && targetAddr < 0x10010000) || // Timer registers
                            (targetAddr >= 0x10020000 && targetAddr < 0x10030000) || // DMAC registers
                            (targetAddr >= 0x12000000 && targetAddr < 0x12010000))   // GS registers
                        {
                            std::cout << "Hardware register access at " << formatAddress(inst.address)
                                      << " to address 0x" << std::hex << targetAddr << std::dec
                                      << " in function " << func.name << std::endl;

                            // We might need to replace this with a special function call but lets just patch it for now
                            m_patchReasons[inst.address] = "Hardware register access to " + formatAddress(targetAddr);
                        }
                    }
                }

                if (inst.opcode == OPCODE_SPECIAL && inst.function == SPECIAL_SYNC)
                {
                    std::cout << "SYNC instruction (memory barrier) at " << formatAddress(inst.address)
                              << " in function " << func.name << std::endl;
                    // We might need to add memory barriers in the recompiled code
                }

                // Detect instructions that use special PS2 features like quad load/store
                if (inst.opcode == OPCODE_LQ || inst.opcode == OPCODE_SQ)
                {
                    std::cout << "Quad word " << (inst.opcode == OPCODE_LQ ? "load" : "store")
                              << " at " << formatAddress(inst.address) << " in function " << func.name << std::endl;
                    // These will require special handling with SIMD instructions
                }
            }
        }

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (const auto &inst : instructions)
            {
                if (inst.isMMI || inst.isVU)
                {
                    std::cout << "Found PS2 multimedia instruction at " << formatAddress(inst.address)
                              << " in function " << func.name << std::endl;

                    // These might need special handling, but we won't patch them with NOPs
                    m_patchReasons[inst.address] = "PS2 multimedia instruction";
                }
            }
        }
    }

    void ElfAnalyzer::analyzeControlFlow()
    {
        std::cout << "Analyzing control flow of functions..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            CFG cfg = buildCFG(func);
            m_functionCFGs[func.start] = cfg;

            std::vector<Instruction> instructions = decodeFunction(func);
            for (const auto &inst : instructions)
            {
                if (inst.opcode == OPCODE_JAL ||
                    (inst.opcode == OPCODE_SPECIAL && inst.function == SPECIAL_JALR))
                {

                    uint32_t targetAddr = 0;

                    if (inst.opcode == OPCODE_JAL)
                    {
                        targetAddr = decodeAbsoluteJumpTarget(inst.address, inst.target);
                    }
                    else
                    {
                        // For JALR, the target is in the register - harder to statically analyze so lets skip it
                        continue;
                    }

                    for (const auto &targetFunc : m_functions)
                    {
                        if (targetFunc.start == targetAddr)
                        {
                            FunctionCall call;
                            call.callerAddress = inst.address;
                            call.calleeAddress = targetAddr;
                            call.calleeName = targetFunc.name;

                            m_functionCalls[func.start].push_back(call);

                            std::cout << "Function " << func.name << " calls " << targetFunc.name
                                      << " at " << formatAddress(inst.address) << std::endl;
                            break;
                        }
                    }
                }
            }
        }
    }

    void ElfAnalyzer::detectJumpTables()
    {
        std::cout << "Detecting jump tables..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (size_t i = 0; i < instructions.size(); i++)
            {
                const auto &inst = instructions[i];

                if (inst.opcode == OPCODE_SLTIU && i + 2 < instructions.size())
                {
                    const auto &nextInst = instructions[i + 1];
                    if (nextInst.opcode == OPCODE_BNE || nextInst.opcode == OPCODE_BEQ)
                    {
                        for (size_t j = i + 2; j < std::min(i + 10, instructions.size()); j++)
                        {
                            const auto &loadInst = instructions[j];

                            if (loadInst.opcode == OPCODE_LW && j + 1 < instructions.size())
                            {
                                const auto &jumpInst = instructions[j + 1];

                                if (jumpInst.opcode == OPCODE_SPECIAL && jumpInst.function == SPECIAL_JR &&
                                    jumpInst.rs == loadInst.rt)
                                {
                                    std::cout << "Detected jump table in function " << func.name
                                              << " at " << formatAddress(loadInst.address) << std::endl;

                                    uint32_t baseAddr = 0;
                                    uint32_t numEntries = inst.immediate; // From the bounds check

                                    for (int k = j - 1; k >= static_cast<int>(i); k--)
                                    {
                                        const auto &addrInst = instructions[k];

                                        if (addrInst.opcode == OPCODE_LUI && k + 1 < instructions.size())
                                        {
                                            const auto &offsetInst = instructions[k + 1];

                                            if ((offsetInst.opcode == OPCODE_ADDIU || offsetInst.opcode == OPCODE_ORI) &&
                                                offsetInst.rs == addrInst.rt && offsetInst.rt == loadInst.rs)
                                            {

                                                baseAddr = (addrInst.immediate << 16) | (offsetInst.immediate & 0xFFFF);
                                                break;
                                            }
                                        }
                                    }

                                    if (baseAddr != 0 && numEntries > 0 && numEntries < 1000)
                                    {
                                        JumpTable jumpTable;
                                        jumpTable.address = baseAddr;
                                        jumpTable.baseRegister = loadInst.rs;

                                        for (uint32_t e = 0; e < numEntries; e++)
                                        {
                                            uint32_t entryAddr = baseAddr + (e * 4);

                                            uint32_t targetAddr = 0;
                                            if (tryReadWord(m_elfParser.get(), entryAddr, targetAddr))
                                            {
                                                JumpTableEntry entry;
                                                entry.index = e;
                                                entry.target = targetAddr;
                                                jumpTable.entries.push_back(entry);

                                                std::cout << "  - Jump table entry " << e << ": 0x"
                                                          << std::hex << targetAddr << std::dec << std::endl;
                                            }
                                        }

                                        if (!jumpTable.entries.empty())
                                        {
                                            m_jumpTables.push_back(jumpTable);
                                        }
                                    }

                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    void ElfAnalyzer::analyzePerformanceCriticalPaths() const
    {
        std::cout << "Analyzing performance-critical paths..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (const auto &inst : instructions)
            {
                if (inst.isBranch)
                {
                    int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                    uint32_t targetAddr = inst.address + 4 + offset;

                    if (targetAddr < inst.address)
                    {
                        size_t loopSize = (inst.address - targetAddr) / 4 + 1;

                        if (loopSize < 20)
                        {
                            std::cout << "Found tight loop in function " << func.name
                                      << " from " << formatAddress(targetAddr)
                                      << " to " << formatAddress(inst.address)
                                      << " (size: " << loopSize << " instructions)" << std::endl;

                            bool hasMultimedia = false;
                            for (const auto &instruction : instructions)
                            {
                                if (instruction.address >= targetAddr && instruction.address <= inst.address)
                                {
                                    if (instruction.isMultimedia)
                                    {
                                        hasMultimedia = true;
                                        break;
                                    }
                                }
                            }

                            if (hasMultimedia)
                            {
                                std::cout << "  - Loop contains multimedia instructions" << std::endl;
                            }
                        }
                    }
                }
            }
        }
    }

    void ElfAnalyzer::identifyRecursiveFunctions()
    {
        std::cout << "Identifying recursive functions..." << std::endl;

        // lets ignore skip and library
        std::unordered_set<std::string> eligible;
        eligible.reserve(m_functions.size());

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            eligible.insert(func.name);
        }

        std::unordered_map<std::string, std::vector<std::string>> callGraph;
        callGraph.reserve(eligible.size());

        for (const auto &func : m_functions)
        {
            if (!eligible.contains(func.name))
            {
                continue;
            }

            auto itCalls = m_functionCalls.find(func.start);
            if (itCalls == m_functionCalls.end())
            {
                continue;
            }

            auto &edges = callGraph[func.name];
            edges.reserve(itCalls->second.size());

            for (const auto &call : itCalls->second)
            {
                // non-eligible nodes to graph.
                if (!eligible.contains(call.calleeName))
                {
                    continue;
                }

                edges.push_back(call.calleeName);
            }
        }

        std::unordered_map<std::string, int> index;
        std::unordered_map<std::string, int> lowlink;
        std::unordered_set<std::string> onStack;
        std::vector<std::string> stack;

        index.reserve(eligible.size());
        lowlink.reserve(eligible.size());
        onStack.reserve(eligible.size());
        stack.reserve(eligible.size());

        int currentIndex = 0;

        std::vector<std::vector<std::string>> sccs;
        sccs.reserve(256);

        std::function<void(const std::string &)> strongconnect;
        strongconnect = [&](const std::string &v)
        {
            index[v] = currentIndex;
            lowlink[v] = currentIndex;
            currentIndex++;

            stack.push_back(v);
            onStack.insert(v);

            auto it = callGraph.find(v);
            if (it != callGraph.end())
            {
                for (const auto &w : it->second)
                {
                    if (!index.contains(w))
                    {
                        strongconnect(w);
                        lowlink[v] = std::min(lowlink[v], lowlink[w]);
                    }
                    else if (onStack.contains(w))
                    {
                        lowlink[v] = std::min(lowlink[v], index[w]);
                    }
                }
            }

            if (lowlink[v] == index[v])
            {
                std::vector<std::string> scc;
                while (!stack.empty())
                {
                    std::string w = stack.back();
                    stack.pop_back();
                    onStack.erase(w);

                    scc.push_back(w);
                    if (w == v)
                    {
                        break;
                    }
                }

                sccs.push_back(std::move(scc));
            }
        };

        for (const auto &name : eligible)
        {
            if (!index.contains(name))
            {
                strongconnect(name);
            }
        }

        // SCC size > 1 -> mutual recursion
        // SCC size == 1 -> direct recursion if it calls itself
        for (const auto &scc : sccs)
        {
            if (scc.size() > 1)
            {
                for (const auto &name : scc)
                {
                    std::cout << "Function " << name << " is part of a mutually recursive cycle" << std::endl;
                }
                continue;
            }

            const std::string &name = scc[0];
            auto it = callGraph.find(name);
            if (it == callGraph.end())
            {
                continue;
            }

            for (const auto &callee : it->second)
            {
                if (callee == name)
                {
                    std::cout << "Function " << name << " is directly recursive" << std::endl;
                    break;
                }
            }
        }
    }

    void ElfAnalyzer::analyzeRegisterUsage() const
    {
        std::cout << "Analyzing register usage patterns..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);
            std::set<uint32_t> regsRead, regsWritten;

            for (const auto &inst : instructions)
            {
                if (inst.rs != 0)
                    regsRead.insert(inst.rs);
                if (inst.rt != 0 && inst.opcode != OPCODE_SW && inst.opcode != OPCODE_SB &&
                    inst.opcode != OPCODE_SH && inst.opcode != OPCODE_SQ)
                {
                    regsRead.insert(inst.rt);
                }

                if (inst.opcode == OPCODE_SPECIAL || inst.opcode == OPCODE_REGIMM ||
                    inst.opcode == OPCODE_COP1 || inst.opcode == OPCODE_COP2)
                {
                    // R-type instructions
                    if (inst.rd != 0)
                        regsWritten.insert(inst.rd);
                }
                else if (inst.opcode == OPCODE_JAL)
                {
                    // JAL writes to $ra (r31)
                    regsWritten.insert(31);
                }
                else if (inst.opcode == OPCODE_LUI || inst.opcode == OPCODE_ADDIU ||
                         inst.opcode == OPCODE_ORI || inst.opcode == OPCODE_LW ||
                         inst.opcode == OPCODE_LB || inst.opcode == OPCODE_LH)
                {
                    // I-type instructions that write to rt
                    if (inst.rt != 0)
                        regsWritten.insert(inst.rt);
                }
            }

            // Check if function follows standard calling convention
            bool hasStackOps = false;
            bool savesFP = false;
            bool savesRA = false;

            for (size_t i = 0; i < std::min(static_cast<size_t>(10), instructions.size()); i++)
            {
                const auto &inst = instructions[i];

                // ADDIU $sp, $sp, -X (allocate stack frame)
                if (inst.opcode == OPCODE_ADDIU && inst.rs == 29 && inst.rt == 29 &&
                    static_cast<int16_t>(inst.immediate) < 0)
                {
                    hasStackOps = true;
                }

                // SW $fp, X($sp) (save frame pointer)
                if (inst.opcode == OPCODE_SW && inst.rt == 30 && inst.rs == 29)
                {
                    savesFP = true;
                }

                // SW $ra, X($sp) (save return address)
                if (inst.opcode == OPCODE_SW && inst.rt == 31 && inst.rs == 29)
                {
                    savesRA = true;
                }
            }

            if (hasStackOps)
            {
                std::cout << "Function " << func.name << " allocates a stack frame" << std::endl;

                if (savesFP)
                    std::cout << "  - Saves frame pointer ($fp)" << std::endl;
                if (savesRA)
                    std::cout << "  - Saves return address ($ra)" << std::endl;
            }

            if (regsRead.contains(4) || regsRead.contains(5) ||
                regsRead.contains(6) || regsRead.contains(7))
            {
                std::cout << "  - Uses argument registers (a0-a3)" << std::endl;
            }

            if (regsWritten.contains(2) || regsWritten.contains(3))
            {
                std::cout << "  - Sets return values (v0-v1)" << std::endl;
            }
        }
    }

    void ElfAnalyzer::analyzeFunctionSignatures() const
    {
        std::cout << "Analyzing function signatures..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            int paramCount = 0;
            bool usesFloatingPoint = false;
            bool usesDoublewords = false;
            bool returnsSomething = false;

            for (const auto &inst : instructions)
            {
                if ((inst.rs >= 4 && inst.rs <= 7) || (inst.rt >= 4 && inst.rt <= 7))
                {
                    paramCount = std::max(paramCount, static_cast<int>(std::max(inst.rs, inst.rt) - 3));
                }

                if (inst.opcode == OPCODE_COP1)
                {
                    usesFloatingPoint = true;
                }

                // Check for 64-bit operations
                if (inst.opcode == OPCODE_LD || inst.opcode == OPCODE_SD ||
                    (inst.opcode == OPCODE_SPECIAL &&
                     (inst.function == SPECIAL_DSLL || inst.function == SPECIAL_DSRL ||
                      inst.function == SPECIAL_DSRA || inst.function == SPECIAL_DSLLV ||
                      inst.function == SPECIAL_DSRLV || inst.function == SPECIAL_DSRAV)))
                {
                    usesDoublewords = true;
                }

                // Check for return value setting, addition we could do as well thous check (inst.opcode == OPCODE_ADDIU && inst.rs == 0) ||  // LI pattern using ADDIU $rt, $zero, imm  and (inst.opcode == OPCODE_ORI && i > 0 && instructions[i - 1].opcode == OPCODE_LUI && instructions[i - 1].rt == inst.rs && inst.rt == inst.rs)
                if ((inst.opcode == OPCODE_ADDIU || inst.opcode == OPCODE_ORI ||
                     inst.opcode == OPCODE_LW) &&
                    (inst.rt == 2 || inst.rt == 3))
                {
                    returnsSomething = true;
                }
                else if (inst.opcode == OPCODE_SPECIAL &&
                         (inst.function == SPECIAL_ADD || inst.function == SPECIAL_ADDU ||
                          inst.function == SPECIAL_SUB || inst.function == SPECIAL_SUBU ||
                          inst.function == SPECIAL_AND || inst.function == SPECIAL_OR ||
                          inst.function == SPECIAL_XOR || inst.function == SPECIAL_NOR) &&
                         (inst.rd == 2 || inst.rd == 3))
                {
                    returnsSomething = true;
                }
            }

            if (paramCount > 0 || usesFloatingPoint || usesDoublewords || returnsSomething)
            {
                std::cout << "Function " << func.name << " signature analysis:" << std::endl;
                if (paramCount > 0)
                {
                    std::cout << "  - Uses approximately " << paramCount << " parameter(s)" << std::endl;
                }
                if (usesFloatingPoint)
                {
                    std::cout << "  - Uses floating point operations" << std::endl;
                }
                if (usesDoublewords)
                {
                    std::cout << "  - Uses 64-bit operations" << std::endl;
                }
                if (returnsSomething)
                {
                    std::cout << "  - Returns a value" << std::endl;
                }
            }
        }
    }

    void ElfAnalyzer::optimizePatches()
    {
        std::cout << "Optimizing patches..." << std::endl;

        std::map<uint32_t, std::vector<uint32_t>> functionPatches;

        for (const auto &patch : m_patches)
        {
            uint32_t patchAddr = patch.first;

            for (const auto &func : m_functions)
            {
                if (patchAddr >= func.start && patchAddr < func.end)
                {
                    functionPatches[func.start].push_back(patchAddr);
                    break;
                }
            }
        }

        for (const auto &[funcStart, patchAddrs] : functionPatches)
        {
            auto funcIt = std::find_if(m_functions.begin(), m_functions.end(),
                                       [funcStart](const Function &f)
                                       { return f.start == funcStart; });

            if (funcIt != m_functions.end())
            {
                const Function &func = *funcIt;

                if (patchAddrs.size() > 3)
                {
                    std::cout << "Function " << func.name << " has " << patchAddrs.size()
                              << " patches. Consider skipping or stubing instead." << std::endl;

                    // If too many patches in one function, maybe better to skip it
                    if (patchAddrs.size() > 5 &&
                        static_cast<double>(patchAddrs.size()) / ((func.end - func.start) / 4) > 0.2 &&
                        !isLibraryFunction(func.name) &&
                        !isDoNotSkipOrStub(func.name))
                    {
                        std::cout << "  - Adding " << func.name << " to skip list due to high patch density" << std::endl;
                        m_skipFunctions.insert(func.name);

                        for (const auto &addr : patchAddrs)
                        {
                            m_patches.erase(addr);
                            m_patchReasons.erase(addr);
                        }
                    }
                }
            }
        }

        std::vector<uint32_t> patchAddrs;
        for (const auto &patch : m_patches)
        {
            patchAddrs.push_back(patch.first);
        }

        if (patchAddrs.size() == 0)
            return;

        std::sort(patchAddrs.begin(), patchAddrs.end());

        for (size_t i = 0; i < patchAddrs.size() - 1; i++)
        {
            if (patchAddrs[i] + 4 == patchAddrs[i + 1])
            {
                std::cout << "Sequential patches at " << formatAddress(patchAddrs[i])
                          << " and " << formatAddress(patchAddrs[i + 1]) << std::endl;

                // If they're both NOPs, we could potentially optimize them together
                if (m_patches[patchAddrs[i]] == 0 && m_patches[patchAddrs[i + 1]] == 0)
                {
                    std::cout << "  - Both are NOPs, could be combined in recompilation" << std::endl;
                }
            }
        }
    }

    bool ElfAnalyzer::identifyMemcpyPattern(const Function &func) const
    {
        std::vector<Instruction> instructions = decodeFunction(func);

        bool hasLoop = false;
        bool loadsData = false;
        bool storesData = false;
        bool incrementsPointers = false;

        for (const auto &inst : instructions)
        {
            if (inst.isBranch)
            {
                int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                if (inst.address + 4 + offset < inst.address)
                {
                    hasLoop = true;
                }
            }

            if (inst.opcode == OPCODE_LW || inst.opcode == OPCODE_LB ||
                inst.opcode == OPCODE_LH || inst.opcode == OPCODE_LD ||
                inst.opcode == OPCODE_LQ)
            {
                loadsData = true;
            }

            if (inst.opcode == OPCODE_SW || inst.opcode == OPCODE_SB ||
                inst.opcode == OPCODE_SH || inst.opcode == OPCODE_SD ||
                inst.opcode == OPCODE_SQ)
            {
                storesData = true;
            }

            if (inst.opcode == OPCODE_ADDIU &&
                (inst.immediate == 4 || inst.immediate == 8 || inst.immediate == 16))
            {
                incrementsPointers = true;
            }
        }

        return hasLoop && loadsData && storesData && incrementsPointers;
    }

    bool ElfAnalyzer::identifyMemsetPattern(const Function &func) const
    {
        std::vector<Instruction> instructions = decodeFunction(func);

        bool hasLoop = false;
        bool usesConstant = false;
        bool storesData = false;
        bool incrementsPointer = false;

        for (const auto &inst : instructions)
        {
            if (inst.isBranch)
            {
                int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                if (inst.address + 4 + offset < inst.address)
                {
                    hasLoop = true;
                }
            }

            if (inst.opcode == OPCODE_LUI || inst.opcode == OPCODE_ORI ||
                inst.opcode == OPCODE_ADDIU || inst.opcode == OPCODE_ANDI)
            {
                usesConstant = true;
            }

            if (inst.opcode == OPCODE_SW || inst.opcode == OPCODE_SB ||
                inst.opcode == OPCODE_SH || inst.opcode == OPCODE_SD ||
                inst.opcode == OPCODE_SQ)
            {
                storesData = true;
            }

            if (inst.opcode == OPCODE_ADDIU &&
                (inst.immediate == 4 || inst.immediate == 8 || inst.immediate == 16))
            {
                incrementsPointer = true;
            }
        }

        return hasLoop && usesConstant && storesData && incrementsPointer;
    }

    bool ElfAnalyzer::identifyStringOperationPattern(const Function &func) const
    {
        std::vector<Instruction> instructions = decodeFunction(func);

        bool hasLoop = false;
        bool checksZero = false;
        bool loadsByte = false;
        bool storesByte = false;

        for (const auto &inst : instructions)
        {
            if (inst.isBranch)
            {
                int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                if (inst.address + 4 + offset < inst.address)
                {
                    hasLoop = true;
                }
            }

            if ((inst.opcode == OPCODE_BEQ && (inst.rs == 0 || inst.rt == 0)) ||
                (inst.opcode == OPCODE_SPECIAL && inst.function == SPECIAL_SLT && inst.rd != 0))
            {
                checksZero = true;
            }

            if (inst.opcode == OPCODE_LB || inst.opcode == OPCODE_LBU)
            {
                loadsByte = true;
            }

            if (inst.opcode == OPCODE_SB)
            {
                storesByte = true;
            }
        }

        return hasLoop && checksZero && (loadsByte || storesByte);
    }

    bool ElfAnalyzer::identifyMathPattern(const Function &func) const
    {
        std::vector<Instruction> instructions = decodeFunction(func);

        int mathOps = 0;
        bool usesFPU = false;

        for (const auto &inst : instructions)
        {
            // Count ALU operations
            if (inst.opcode == OPCODE_SPECIAL &&
                (inst.function == SPECIAL_ADD || inst.function == SPECIAL_ADDU ||
                 inst.function == SPECIAL_SUB || inst.function == SPECIAL_SUBU ||
                 inst.function == SPECIAL_MULT || inst.function == SPECIAL_MULTU ||
                 inst.function == SPECIAL_DIV || inst.function == SPECIAL_DIVU))
            {
                mathOps++;
            }

            // Check for FPU usage
            if (inst.opcode == OPCODE_COP1)
            {
                usesFPU = true;
                mathOps++;
            }
        }

        // If more than 30% of instructions are math operations, it's likely a math function
        return mathOps > instructions.size() * 0.3 || usesFPU;
    }

    CFG ElfAnalyzer::buildCFG(const Function &function) const
    {
        CFG cfg;
        std::vector<Instruction> instructions = decodeFunction(function);
        std::map<uint32_t, size_t> addrToIndex;

        for (size_t i = 0; i < instructions.size(); i++)
        {
            addrToIndex[instructions[i].address] = i;
        }

        std::set<uint32_t> leaders = {function.start}; // Entry point is always a leader

        for (size_t i = 0; i < instructions.size(); i++)
        {
            const auto &inst = instructions[i];

            if (inst.isBranch || inst.isJump)
            {
                size_t fallthroughIndex = i + (inst.hasDelaySlot ? 2 : 1);
                if (fallthroughIndex < instructions.size())
                {
                    leaders.insert(instructions[fallthroughIndex].address);
                }

                if (inst.isBranch)
                {
                    int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                    uint32_t target = inst.address + 4 + offset;
                    leaders.insert(target);
                }

                // Jump target for J/JAL
                if ((inst.opcode == OPCODE_J || inst.opcode == OPCODE_JAL) && !inst.isCall)
                {
                    uint32_t target = decodeAbsoluteJumpTarget(inst.address, inst.target);
                    leaders.insert(target);
                }
            }
        }

        uint32_t currentLeader = 0;
        CFGNode currentNode;

        for (size_t i = 0; i < instructions.size(); i++)
        {
            const auto &inst = instructions[i];

            if (leaders.contains(inst.address))
            {
                if (currentLeader != 0)
                {
                    currentNode.endAddress = instructions[i - 1].address;
                    cfg[currentLeader] = currentNode;
                }

                currentLeader = inst.address;
                currentNode = CFGNode();
                currentNode.startAddress = currentLeader;
                currentNode.isJumpTarget = true;
                currentNode.instructions.clear();
            }

            currentNode.instructions.push_back(inst);

            if (i == instructions.size() - 1)
            {
                currentNode.endAddress = inst.address;
                cfg[currentLeader] = currentNode;
            }
        }

        for (auto &[addr, node] : cfg)
        {
            if (node.instructions.empty())
            {
                continue;
            }

            const auto &lastInst = node.instructions.back();
            const Instruction *terminator = &lastInst;

            if (node.instructions.size() >= 2)
            {
                const auto &candidate = node.instructions[node.instructions.size() - 2];
                if (candidate.hasDelaySlot &&
                    (candidate.isBranch || candidate.isJump) &&
                    candidate.address + 4 == lastInst.address)
                {
                    terminator = &candidate;
                }
            }

            if (terminator->isBranch)
            {
                int32_t offset = static_cast<int16_t>(terminator->immediate) << 2;
                uint32_t targetAddr = terminator->address + 4 + offset;

                if (cfg.contains(targetAddr))
                {
                    node.successors.push_back(targetAddr);
                    cfg[targetAddr].predecessors.push_back(addr);
                }

                bool likelyBranch = (terminator->opcode == OPCODE_BEQL ||
                                     terminator->opcode == OPCODE_BNEL ||
                                     terminator->opcode == OPCODE_BLEZL ||
                                     terminator->opcode == OPCODE_BGTZL);

                if (!likelyBranch)
                {
                    const uint32_t step = terminator->hasDelaySlot ? 8 : 4;
                    if (terminator->address + step <= function.end)
                    {
                        uint32_t nextAddr = terminator->address + step;

                        for (const auto &[blockAddr, blockNode] : cfg)
                        {
                            if (blockAddr == nextAddr ||
                                (nextAddr > blockAddr && nextAddr <= blockNode.endAddress))
                            {
                                node.successors.push_back(blockAddr);
                                cfg[blockAddr].predecessors.push_back(addr);
                                break;
                            }
                        }
                    }
                }
            }
            else if (terminator->isJump)
            {
                if (terminator->opcode == OPCODE_J || terminator->opcode == OPCODE_JAL)
                {
                    // Direct jump
                    uint32_t targetAddr = decodeAbsoluteJumpTarget(terminator->address, terminator->target);

                    // Only add successor if it's within this function
                    if (targetAddr >= function.start && targetAddr < function.end &&
                        cfg.contains(targetAddr))
                    {
                        node.successors.push_back(targetAddr);
                        cfg[targetAddr].predecessors.push_back(addr);
                    }
                }
                // We don't handle indirect jumps (JR/JALR) statically
            }
            else if (!lastInst.isReturn)
            {
                if (lastInst.address + 4 <= function.end)
                {
                    uint32_t nextAddr = lastInst.address + 4;

                    for (const auto &[blockAddr, blockNode] : cfg)
                    {
                        if (blockAddr == nextAddr)
                        {
                            node.successors.push_back(blockAddr);
                            cfg[blockAddr].predecessors.push_back(addr);
                            break;
                        }
                    }
                }
            }
        }

        return cfg;
    }

    std::string ElfAnalyzer::escapeBackslashes(const std::string &path)
    {
        std::string result;
        for (char ch : path)
        {
            if (ch == '\\')
                result.append("\\\\");
            else
                result.push_back(ch);
        }
        return result;
    }

    static bool hasPs2ApiPrefix(const std::string &name)
    {
        if (name.empty())
            return false;

        const std::vector<std::string> libraryPrefixes = {
            "sce", "Sce", "SCE",   // Sony prefixes
            "sif", "Sif", "SIF",   // SIF functions
            "pad", "Pad", "PAD",   // Pad functions
            "gs", "Gs", "GS",      // Graphics Synthesizer
            "dma", "Dma", "DMA",   // DMA functions
            "iop", "Iop", "IOP",   // IOP functions
            "vif", "Vif", "VIF",   // VIF functions
            "spu", "Spu", "SPU",   // SPU functions
            "mc", "Mc", "MC",      // Memory Card functions
            "libc", "Libc", "LIBC" // C library functions
        };

        std::string base = name;
        if (base[0] == '_' && base.size() > 1)
        {
            base = base.substr(1);
        }

        for (const auto &prefix : libraryPrefixes)
        {
            if (base.rfind(prefix, 0) == 0)
            {
                return true;
            }
        }

        return false;
    }

    static bool isDoNotSkipOrStub(const std::string &name)
    {
        static const std::unordered_set<std::string> kDoNotSkipOrStub = {
            "topThread",
            "cmd_sem_init"};

        return kDoNotSkipOrStub.contains(name);
    }

    bool ElfAnalyzer::isSystemFunction(const std::string &name) const
    {
        static const std::unordered_set<std::string> systemFuncs = {
            "entry", "_start", "_init", "_fini",
            "abort", "exit", "_exit",
            "_profiler_start", "_profiler_stop",
            "__main", "__do_global_ctors", "__do_global_dtors",
            "_GLOBAL__sub_I_", "_GLOBAL__sub_D_",
            "__ctor_list", "__dtor_list", "_edata", "_end",
            "etext", "__exidx_start", "__exidx_end",
            "_ftext", "__bss_start", "__bss_start__",
            "__bss_end__", "__end__", "_stack", "_dso_handle"};

        return systemFuncs.contains(name) ||
               name.find("__") == 0 ||
               name.find(".") == 0; // .text.* or .plt.* symbols
    }

    bool ElfAnalyzer::isLibraryFunction(const std::string &name) const
    {
        if (name.empty())
            return false;

        if (m_knownLibNames.find(name) != m_knownLibNames.end())
            return true;

        if (hasPs2ApiPrefix(name))
            return true;

        // Check for common C/C++ library function names
        static const std::regex cLibPattern("^_*(mem|str|time|f?printf|f?scanf|malloc|free|calloc|realloc|atoi|itoa|rand|srand|abort|exit|atexit|getenv|system|bsearch|qsort|abs|labs|div|ldiv|mblen|mbtowc|wctomb|mbstowcs|wcstombs).*");
        if (std::regex_match(name, cLibPattern))
        {
            return true;
        }

        return false;
    }

    std::vector<Instruction> ElfAnalyzer::decodeFunction(const Function &function) const
    {
        std::vector<Instruction> instructions;

        for (uint32_t addr = function.start; addr < function.end; addr += 4)
        {
            uint32_t rawInstruction = 0;
            if (!tryReadWord(m_elfParser.get(), addr, rawInstruction))
            {
                continue;
            }

            try
            {
                Instruction inst = m_decoder->decodeInstruction(addr, rawInstruction);
                instructions.push_back(inst);
            }
            catch (const std::exception &e)
            {
                std::cerr << "Error decoding instruction at " << formatAddress(addr)
                          << ": " << e.what() << std::endl;
            }
        }

        return instructions;
    }

    std::string ElfAnalyzer::formatAddress(uint32_t address) const
    {
        std::stringstream ss;
        ss << "0x" << std::hex << std::setw(8) << std::setfill('0') << address;
        return ss.str();
    }

    bool ElfAnalyzer::hasMMIInstructions(const Function &function) const
    {
        std::vector<Instruction> instructions = decodeFunction(function);

        for (const auto &inst : instructions)
        {
            if (inst.isMMI || inst.opcode == OPCODE_MMI)
            {
                return true;
            }
        }

        return false;
    }

    bool ElfAnalyzer::hasVUInstructions(const Function &function) const
    {
        std::vector<Instruction> instructions = decodeFunction(function);

        for (const auto &inst : instructions)
        {
            if (inst.isVU || inst.opcode == OPCODE_COP2)
            {
                return true;
            }
        }

        return false;
    }

    bool ElfAnalyzer::identifyFunctionType(const Function &function)
    {
        if (m_libFunctions.contains(function.name) ||
            m_skipFunctions.contains(function.name))
        {
            return false;
        }
        if (isDoNotSkipOrStub(function.name))
        {
            return false;
        }
        if (hasPs2ApiPrefix(function.name))
        {
            return false;
        }

        std::vector<Instruction> instructions = decodeFunction(function);

        bool hasHardwareIO = false;
        bool hasComplexMMI = false;
        bool isVeryLarge = instructions.size() > 500; // Arbitrary large function threshold

        for (const auto &inst : instructions)
        {
            // Check for LUI+SW combinations to hardware registers
            if (inst.opcode == OPCODE_LUI)
            {
                uint32_t upperAddr = inst.immediate << 16;

                // Check if upper address is in hardware region
                if ((upperAddr >= 0x10000000 && upperAddr < 0x14000000) || // I/O area
                    (upperAddr >= 0x1F800000 && upperAddr < 0x1F900000))   // Scratchpad RAM
                {
                    hasHardwareIO = true;
                }
            }

            // Check for complex MMI operations
            if (inst.isMMI &&
                (inst.opcode == OPCODE_MMI &&
                 (inst.function == MMI_MMI0 || inst.function == MMI_MMI1 ||
                  inst.function == MMI_MMI2 || inst.function == MMI_MMI3)))
            {
                hasComplexMMI = true;
            }
        }

        if (hasHardwareIO)
        {
            m_skipFunctions.insert(function.name);
            std::cout << "Skipping function " << function.name << " due to hardware I/O" << std::endl;
            return true;
        }

        if (hasComplexMMI && isVeryLarge)
        {
            m_skipFunctions.insert(function.name);
            std::cout << "Skipping large function " << function.name << " with complex MMI" << std::endl;
            return true;
        }

        return false;
    }

    void ElfAnalyzer::categorizeFunction(Function &function)
    {
        identifyFunctionType(function);

        if (isSelfModifyingCode(function))
        {
            std::cout << "Function " << function.name << " contains self-modifying code" << std::endl;
            if (!isLibraryFunction(function.name) && !isDoNotSkipOrStub(function.name))
            {
                m_skipFunctions.insert(function.name);
            }
        }

        if (isLoopHeavyFunction(function))
        {
            std::cout << "Function " << function.name << " is loop-heavy, may need optimization" << std::endl;
        }
    }

    bool ElfAnalyzer::isSelfModifyingCode(const Function &function) const
    {
        std::vector<Instruction> instructions = decodeFunction(function);

        for (size_t i = 0; i < instructions.size(); i++)
        {
            const auto &inst = instructions[i];

            if ((inst.opcode == OPCODE_SW || inst.opcode == OPCODE_SH ||
                 inst.opcode == OPCODE_SB || inst.opcode == OPCODE_SQ))
            {

                uint32_t baseAddr = 0;

                // Look for preceding LUI instruction
                for (int j = i - 1; j >= 0 && j >= static_cast<int>(i) - 5; j--)
                {
                    const auto &prevInst = instructions[j];

                    if (prevInst.opcode == OPCODE_LUI && prevInst.rt == inst.rs)
                    {
                        baseAddr = prevInst.immediate << 16;
                        break;
                    }
                }

                if (baseAddr != 0)
                {
                    uint32_t targetAddr = baseAddr + static_cast<int16_t>(inst.immediate);

                    // Check if target address is within a code section
                    for (const auto &section : m_sections)
                    {
                        if (section.isCode && targetAddr >= section.address &&
                            targetAddr < section.address + section.size)
                        {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    }

    bool ElfAnalyzer::isLoopHeavyFunction(const Function &function) const
    {
        std::vector<Instruction> instructions = decodeFunction(function);
        int loopCount = 0;

        for (const auto &inst : instructions)
        {
            if (inst.isBranch)
            {
                int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                if (offset < 0)
                {
                    loopCount++;
                }
            }
        }

        // Consider it loop-heavy if it has more than 5 loops
        return loopCount > 5;
    }

    uint32_t ElfAnalyzer::getSuccessor(const Instruction &inst, uint32_t currentAddr)
    {
        if (inst.isBranch)
        {
            int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
            return currentAddr + 4 + offset;
        }

        if (inst.opcode == OPCODE_J || inst.opcode == OPCODE_JAL)
        {
            return decodeAbsoluteJumpTarget(currentAddr, inst.target);
        }

        return currentAddr + 4;
    }

    static uint32_t decodeAbsoluteJumpTarget(uint32_t instructionAddress, uint32_t targetField)
    {
        return ((instructionAddress + 4) & 0xF0000000u) | (targetField << 2);
    }

    static bool tryReadWord(const ElfParser *parser, uint32_t address, uint32_t &outWord)
    {
        if (parser == nullptr)
        {
            return false;
        }

        if (address > (std::numeric_limits<uint32_t>::max() - 3))
        {
            return false;
        }

        if (!parser->isValidAddress(address) || !parser->isValidAddress(address + 3))
        {
            return false;
        }

        try
        {
            outWord = parser->readWord(address);
            return true;
        }
        catch (const std::exception &)
        {
            return false;
        }
    }
}
